/**
 * State persistence module for DCP plugin.
 * Persists pruned tool IDs across sessions so they survive OpenCode restarts.
 * Storage location: ~/.local/share/opencode/storage/plugin/dcp/{sessionId}.json
 */
import * as fs from "fs/promises";
import { existsSync } from "fs";
import { homedir } from "os";
import { join } from "path";
const STORAGE_DIR = join(process.env.XDG_DATA_HOME || join(homedir(), ".local", "share"), "opencode", "storage", "plugin", "dcp");
async function ensureStorageDir() {
    if (!existsSync(STORAGE_DIR)) {
        await fs.mkdir(STORAGE_DIR, { recursive: true });
    }
}
function getSessionFilePath(sessionId) {
    return join(STORAGE_DIR, `${sessionId}.json`);
}
export async function saveSessionState(sessionState, logger, sessionName) {
    try {
        if (!sessionState.sessionId) {
            return;
        }
        await ensureStorageDir();
        const state = {
            sessionName: sessionName,
            prune: {
                tools: Object.fromEntries(sessionState.prune.tools),
                messages: Object.fromEntries(sessionState.prune.messages),
            },
            compressSummaries: sessionState.compressSummaries,
            stats: sessionState.stats,
            lastUpdated: new Date().toISOString(),
        };
        const filePath = getSessionFilePath(sessionState.sessionId);
        const content = JSON.stringify(state, null, 2);
        await fs.writeFile(filePath, content, "utf-8");
        logger.info("Saved session state to disk", {
            sessionId: sessionState.sessionId,
            totalTokensSaved: state.stats.totalPruneTokens,
        });
    }
    catch (error) {
        logger.error("Failed to save session state", {
            sessionId: sessionState.sessionId,
            error: error?.message,
        });
    }
}
export async function loadSessionState(sessionId, logger) {
    try {
        const filePath = getSessionFilePath(sessionId);
        if (!existsSync(filePath)) {
            return null;
        }
        const content = await fs.readFile(filePath, "utf-8");
        const state = JSON.parse(content);
        const hasNewFormat = state?.prune?.tools && typeof state.prune.tools === "object";
        const hasLegacyFormat = Array.isArray(state?.prune?.toolIds);
        if (!state || !state.prune || (!hasNewFormat && !hasLegacyFormat) || !state.stats) {
            logger.warn("Invalid session state file, ignoring", {
                sessionId: sessionId,
            });
            return null;
        }
        if (Array.isArray(state.compressSummaries)) {
            const validSummaries = state.compressSummaries.filter((s) => s !== null &&
                typeof s === "object" &&
                typeof s.anchorMessageId === "string" &&
                typeof s.summary === "string");
            if (validSummaries.length !== state.compressSummaries.length) {
                logger.warn("Filtered out malformed compressSummaries entries", {
                    sessionId: sessionId,
                    original: state.compressSummaries.length,
                    valid: validSummaries.length,
                });
            }
            state.compressSummaries = validSummaries;
        }
        else {
            state.compressSummaries = [];
        }
        logger.info("Loaded session state from disk", {
            sessionId: sessionId,
        });
        return state;
    }
    catch (error) {
        logger.warn("Failed to load session state", {
            sessionId: sessionId,
            error: error?.message,
        });
        return null;
    }
}
export async function loadAllSessionStats(logger) {
    const result = {
        totalTokens: 0,
        totalTools: 0,
        totalMessages: 0,
        sessionCount: 0,
    };
    try {
        if (!existsSync(STORAGE_DIR)) {
            return result;
        }
        const files = await fs.readdir(STORAGE_DIR);
        const jsonFiles = files.filter((f) => f.endsWith(".json"));
        for (const file of jsonFiles) {
            try {
                const filePath = join(STORAGE_DIR, file);
                const content = await fs.readFile(filePath, "utf-8");
                const state = JSON.parse(content);
                if (state?.stats?.totalPruneTokens && state?.prune) {
                    result.totalTokens += state.stats.totalPruneTokens;
                    result.totalTools += state.prune.tools
                        ? Object.keys(state.prune.tools).length
                        : (state.prune.toolIds?.length ?? 0);
                    result.totalMessages += state.prune.messages
                        ? Object.keys(state.prune.messages).length
                        : (state.prune.messageIds?.length ?? 0);
                    result.sessionCount++;
                }
            }
            catch {
                // Skip invalid files
            }
        }
        logger.debug("Loaded all-time stats", result);
    }
    catch (error) {
        logger.warn("Failed to load all-time stats", { error: error?.message });
    }
    return result;
}
//# sourceMappingURL=persistence.js.map